'use strict';

// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCustomHeaders = exports.authModeParams = exports.normalizeMutationInput = exports.buildGraphQLVariables = exports.generateGraphQLDocument = exports.generateSelectionSet = exports.selectionSetIRToString = exports.customSelectionSetToIR = exports.getDefaultSelectionSetForNonModelWithIR = exports.graphQLOperationsInfo = exports.initializeModel = exports.flattenItems = void 0;
const resolveOwnerFields_1 = require("../utils/resolveOwnerFields");
const connectionType = {
    HAS_ONE: 'HAS_ONE',
    HAS_MANY: 'HAS_MANY',
    BELONGS_TO: 'BELONGS_TO',
};
/**
 *
 * @param GraphQL response object
 * @returns response object with `items` properties flattened
 */
const flattenItems = (obj) => {
    const res = {};
    Object.entries(obj).forEach(([prop, value]) => {
        if (typeof value === 'object' && !Array.isArray(value) && value !== null) {
            if (value.items !== undefined) {
                res[prop] = value.items.map((item) => (0, exports.flattenItems)(item));
                return;
            }
            res[prop] = (0, exports.flattenItems)(value);
            return;
        }
        res[prop] = value;
    });
    return res;
};
exports.flattenItems = flattenItems;
// TODO: this should accept single result to support CRUD methods; create helper for array/list
function initializeModel(client, modelName, result, modelIntrospection, authMode, authToken, context = false) {
    const introModel = modelIntrospection.models[modelName];
    const introModelFields = introModel.fields;
    const modelFields = Object.entries(introModelFields)
        .filter(([_, field]) => field?.type?.model !== undefined)
        .map(([fieldName]) => fieldName);
    return result.map((record) => {
        const initializedRelationalFields = {};
        for (const fieldName of modelFields) {
            const modelField = introModelFields[fieldName];
            const modelFieldType = modelField?.type;
            const relatedModelName = modelFieldType.model;
            const relatedModel = modelIntrospection.models[relatedModelName];
            const relatedModelPKFieldName = relatedModel.primaryKeyInfo.primaryKeyFieldName;
            const relatedModelSKFieldNames = relatedModel.primaryKeyInfo.sortKeyFieldNames;
            const relationType = modelField.association?.connectionType;
            let connectionFields = [];
            if (modelField.association &&
                'associatedWith' in modelField.association) {
                connectionFields = modelField.association.associatedWith;
            }
            const targetNames = [];
            if (modelField.association && 'targetNames' in modelField.association) {
                targetNames.push(...modelField.association.targetNames);
            }
            switch (relationType) {
                case connectionType.HAS_ONE:
                case connectionType.BELONGS_TO: {
                    const sortKeyValues = relatedModelSKFieldNames.reduce(
                    // TODO(Eslint): is this implementation correct?
                    // eslint-disable-next-line array-callback-return
                    (acc, curVal) => {
                        if (record[curVal]) {
                            return (acc[curVal] = record[curVal]);
                        }
                    }, {});
                    if (context) {
                        initializedRelationalFields[fieldName] = (contextSpec, options) => {
                            if (record[targetNames[0]]) {
                                return client.models[relatedModelName].get(contextSpec, {
                                    [relatedModelPKFieldName]: record[targetNames[0]],
                                    ...sortKeyValues,
                                }, {
                                    authMode: options?.authMode || authMode,
                                    authToken: options?.authToken || authToken,
                                });
                            }
                            return undefined;
                        };
                    }
                    else {
                        initializedRelationalFields[fieldName] = (options) => {
                            if (record[targetNames[0]]) {
                                return client.models[relatedModelName].get({
                                    [relatedModelPKFieldName]: record[targetNames[0]],
                                    ...sortKeyValues,
                                }, {
                                    authMode: options?.authMode || authMode,
                                    authToken: options?.authToken || authToken,
                                });
                            }
                            return undefined;
                        };
                    }
                    break;
                }
                case connectionType.HAS_MANY: {
                    const parentPk = introModel.primaryKeyInfo.primaryKeyFieldName;
                    const parentSK = introModel.primaryKeyInfo.sortKeyFieldNames;
                    // M:N check - TODO: refactor
                    const relatedModelField = relatedModel.fields[connectionFields[0]];
                    const relatedModelFieldType = relatedModelField.type;
                    if (relatedModelFieldType.model) {
                        let relatedTargetNames = [];
                        if (relatedModelField.association &&
                            'targetNames' in relatedModelField.association) {
                            relatedTargetNames = relatedModelField.association?.targetNames;
                        }
                        const hasManyFilter = relatedTargetNames.map((field, idx) => {
                            if (idx === 0) {
                                return { [field]: { eq: record[parentPk] } };
                            }
                            return { [field]: { eq: record[parentSK[idx - 1]] } };
                        });
                        if (context) {
                            initializedRelationalFields[fieldName] = (contextSpec, options) => {
                                if (record[parentPk]) {
                                    return client.models[relatedModelName].list(contextSpec, {
                                        filter: { and: hasManyFilter },
                                        limit: options?.limit,
                                        nextToken: options?.nextToken,
                                        authMode: options?.authMode || authMode,
                                        authToken: options?.authToken || authToken,
                                    });
                                }
                                return [];
                            };
                        }
                        else {
                            initializedRelationalFields[fieldName] = (options) => {
                                if (record[parentPk]) {
                                    return client.models[relatedModelName].list({
                                        filter: { and: hasManyFilter },
                                        limit: options?.limit,
                                        nextToken: options?.nextToken,
                                        authMode: options?.authMode || authMode,
                                        authToken: options?.authToken || authToken,
                                    });
                                }
                                return [];
                            };
                        }
                        break;
                    }
                    const hasManyFilter = connectionFields.map((field, idx) => {
                        if (idx === 0) {
                            return { [field]: { eq: record[parentPk] } };
                        }
                        return { [field]: { eq: record[parentSK[idx - 1]] } };
                    });
                    if (context) {
                        initializedRelationalFields[fieldName] = (contextSpec, options) => {
                            if (record[parentPk]) {
                                return client.models[relatedModelName].list(contextSpec, {
                                    filter: { and: hasManyFilter },
                                    limit: options?.limit,
                                    nextToken: options?.nextToken,
                                    authMode: options?.authMode || authMode,
                                    authToken: options?.authToken || authToken,
                                });
                            }
                            return [];
                        };
                    }
                    else {
                        initializedRelationalFields[fieldName] = (options) => {
                            if (record[parentPk]) {
                                return client.models[relatedModelName].list({
                                    filter: { and: hasManyFilter },
                                    limit: options?.limit,
                                    nextToken: options?.nextToken,
                                    authMode: options?.authMode || authMode,
                                    authToken: options?.authToken || authToken,
                                });
                            }
                            return [];
                        };
                    }
                    break;
                }
            }
        }
        return { ...record, ...initializedRelationalFields };
    });
}
exports.initializeModel = initializeModel;
exports.graphQLOperationsInfo = {
    CREATE: { operationPrefix: 'create', usePlural: false },
    READ: { operationPrefix: 'get', usePlural: false },
    UPDATE: { operationPrefix: 'update', usePlural: false },
    DELETE: { operationPrefix: 'delete', usePlural: false },
    LIST: { operationPrefix: 'list', usePlural: true },
    INDEX_QUERY: { operationPrefix: '', usePlural: false },
    ONCREATE: { operationPrefix: 'onCreate', usePlural: false },
    ONUPDATE: { operationPrefix: 'onUpdate', usePlural: false },
    ONDELETE: { operationPrefix: 'onDelete', usePlural: false },
    OBSERVE_QUERY: { operationPrefix: 'observeQuery', usePlural: false },
};
const SELECTION_SET_WILDCARD = '*';
const getDefaultSelectionSetForNonModelWithIR = (nonModelDefinition, modelIntrospection) => {
    const { fields } = nonModelDefinition;
    const mappedFields = Object.values(fields)
        .map(({ type, name }) => {
        if (typeof type.enum === 'string') {
            return [name, FIELD_IR];
        }
        if (typeof type.nonModel === 'string') {
            return [
                name,
                (0, exports.getDefaultSelectionSetForNonModelWithIR)(modelIntrospection.nonModels[type.nonModel], modelIntrospection),
            ];
        }
        if (typeof type === 'string') {
            return [name, FIELD_IR];
        }
        return undefined;
    })
        .filter((pair) => pair !== undefined);
    return Object.fromEntries(mappedFields);
};
exports.getDefaultSelectionSetForNonModelWithIR = getDefaultSelectionSetForNonModelWithIR;
const getDefaultSelectionSetForModelWithIR = (modelDefinition, modelIntrospection) => {
    const { fields } = modelDefinition;
    const mappedFields = Object.values(fields)
        .map(({ type, name }) => {
        if (typeof type.enum === 'string' ||
            typeof type === 'string') {
            return [name, FIELD_IR];
        }
        if (typeof type.nonModel === 'string') {
            return [
                name,
                (0, exports.getDefaultSelectionSetForNonModelWithIR)(modelIntrospection.nonModels[type.nonModel], modelIntrospection),
            ];
        }
        return undefined;
    })
        .filter((pair) => pair !== undefined);
    const ownerFields = (0, resolveOwnerFields_1.resolveOwnerFields)(modelDefinition).map((field) => [
        field,
        FIELD_IR,
    ]);
    return Object.fromEntries(mappedFields.concat(ownerFields));
};
function defaultSelectionSetForModel(modelDefinition) {
    // fields that are explicitly part of the graphql schema; not
    // inferred from owner auth rules.
    const { fields } = modelDefinition;
    const explicitFields = Object.values(fields)
        // Default selection set omits model fields
        .map(({ type, name }) => {
        if (typeof type === 'string')
            return name;
        if (typeof type === 'object') {
            if (typeof type?.enum === 'string') {
                return name;
            }
            else if (typeof type?.nonModel === 'string') {
                return `${name}.${SELECTION_SET_WILDCARD}`;
            }
        }
        return undefined;
    })
        .filter(Boolean);
    // fields used for owner auth rules that may or may not also
    // be explicit on the model.
    const ownerFields = (0, resolveOwnerFields_1.resolveOwnerFields)(modelDefinition);
    return Array.from(new Set(explicitFields.concat(ownerFields)));
}
const FIELD_IR = '';
/**
 * Generates nested Custom Selection Set IR from path
 *
 * @param modelDefinitions
 * @param modelName
 * @param selectionSet - array of object paths
 * @example
 * ### Given
 * `selectionSet = ['id', 'comments.post.id']`
 * ### Returns
 * ```ts
 * {
 *   id: '',
 *   comments: {
 *     items: { post: { id: '' } }
 *   }
 * }
 * ```
 */
function customSelectionSetToIR(modelIntrospection, modelName, selectionSet) {
    const dotNotationToObject = (path, modelOrNonModelName) => {
        const [fieldName, ...rest] = path.split('.');
        const nested = rest[0];
        const modelOrNonModelDefinition = modelIntrospection.models[modelOrNonModelName] ??
            modelIntrospection.nonModels[modelOrNonModelName];
        const modelOrNonModelFields = modelOrNonModelDefinition?.fields;
        const relatedModel = modelOrNonModelFields?.[fieldName]?.type?.model;
        const relatedModelDefinition = modelIntrospection.models[relatedModel];
        const relatedNonModel = modelOrNonModelFields?.[fieldName]?.type?.nonModel;
        const relatedNonModelDefinition = modelIntrospection.nonModels[relatedNonModel];
        const isModelOrNonModelOrFieldType = relatedModelDefinition
            ? 'model'
            : relatedNonModelDefinition
                ? 'nonModel'
                : 'field';
        if (isModelOrNonModelOrFieldType === 'nonModel') {
            let result = {};
            if (!nested) {
                throw Error(`${fieldName} must declare a wildcard (*) or a field of custom type ${relatedNonModel}`);
            }
            if (nested === SELECTION_SET_WILDCARD) {
                result = {
                    [fieldName]: (0, exports.getDefaultSelectionSetForNonModelWithIR)(relatedNonModelDefinition, modelIntrospection),
                };
            }
            else {
                result = {
                    [fieldName]: dotNotationToObject(rest.join('.'), relatedNonModel),
                };
            }
            return result;
        }
        else if (isModelOrNonModelOrFieldType === 'model') {
            let result = {};
            if (!nested) {
                throw Error(`${fieldName} must declare a wildcard (*) or a field of model ${relatedModel}`);
            }
            if (nested === SELECTION_SET_WILDCARD) {
                const nestedRelatedModelDefinition = modelIntrospection.models[relatedModel];
                result = {
                    [fieldName]: getDefaultSelectionSetForModelWithIR(nestedRelatedModelDefinition, modelIntrospection),
                };
            }
            else {
                result = {
                    [fieldName]: dotNotationToObject(rest.join('.'), relatedModel),
                };
            }
            if (modelOrNonModelFields[fieldName]?.isArray) {
                result = {
                    [fieldName]: {
                        items: result[fieldName],
                    },
                };
            }
            return result;
        }
        else {
            const modelField = modelOrNonModelFields?.[fieldName];
            const nonModelDefinition = modelIntrospection.nonModels[modelOrNonModelName];
            const nonModelField = nonModelDefinition?.fields?.[fieldName];
            if (!nonModelDefinition) {
                const isOwnerField = (0, resolveOwnerFields_1.resolveOwnerFields)(modelOrNonModelDefinition).includes(fieldName);
                if (!modelField && !isOwnerField) {
                    throw Error(`${fieldName} is not a field of model ${modelOrNonModelName}`);
                }
            }
            else {
                if (!nonModelField) {
                    throw Error(`${fieldName} is not a field of custom type ${modelOrNonModelName}`);
                }
            }
            return { [fieldName]: FIELD_IR };
        }
    };
    return selectionSet.reduce((resultObj, path) => deepMergeSelectionSetObjects(dotNotationToObject(path, modelName), resultObj), {});
}
exports.customSelectionSetToIR = customSelectionSetToIR;
/**
 * Stringifies selection set IR
 * * @example
 * ### Given
 * ```ts
 * {
 *   id: '',
 *   comments: {
 *     items: { post: { id: '' } }
 *   }
 * }
 * ```
 * ### Returns
 * `'id comments { items { post { id } } }'`
 */
function selectionSetIRToString(obj) {
    const res = [];
    Object.entries(obj).forEach(([fieldName, value]) => {
        if (value === FIELD_IR) {
            res.push(fieldName);
        }
        else if (typeof value === 'object' && value !== null) {
            if (value?.items) {
                res.push(fieldName, '{', 'items', '{', selectionSetIRToString(value.items), '}', '}');
            }
            else {
                res.push(fieldName, '{', selectionSetIRToString(value), '}');
            }
        }
    });
    return res.join(' ');
}
exports.selectionSetIRToString = selectionSetIRToString;
/**
 * Recursively merges selection set objects from `source` onto `target`.
 *
 * `target` will be updated. `source` will be left alone.
 *
 * @param source The object to merge into target.
 * @param target The object to be mutated.
 */
function deepMergeSelectionSetObjects(source, target) {
    const isObject = (obj) => obj && typeof obj === 'object';
    for (const key in source) {
        // This verification avoids 'Prototype Pollution' issue
        if (!Object.prototype.hasOwnProperty.call(source, key))
            continue;
        if (Object.prototype.hasOwnProperty.call(target, key) &&
            isObject(target[key])) {
            deepMergeSelectionSetObjects(source[key], target[key]);
        }
        else {
            target[key] = source[key];
        }
    }
    return target;
}
function generateSelectionSet(modelIntrospection, modelName, selectionSet) {
    const modelDefinition = modelIntrospection.models[modelName];
    const selSetIr = customSelectionSetToIR(modelIntrospection, modelName, selectionSet ?? defaultSelectionSetForModel(modelDefinition));
    const selSetString = selectionSetIRToString(selSetIr);
    return selSetString;
}
exports.generateSelectionSet = generateSelectionSet;
function generateGraphQLDocument(modelIntrospection, modelName, modelOperation, listArgs, indexMeta) {
    const modelDefinition = modelIntrospection.models[modelName];
    const { name, pluralName, fields, primaryKeyInfo: { isCustomPrimaryKey, primaryKeyFieldName, sortKeyFieldNames, }, } = modelDefinition;
    // Use pascal case of the model name to generate the operations and the arguments.
    // This is required to be in sync with the resources generated by the GraphQL transformers.
    const namePascalCase = name.charAt(0).toUpperCase() + name.slice(1);
    const pluralNamePascalCase = pluralName.charAt(0).toUpperCase() + pluralName.slice(1);
    const { operationPrefix, usePlural } = exports.graphQLOperationsInfo[modelOperation];
    const { selectionSet } = listArgs || {};
    let graphQLFieldName;
    let indexQueryArgs;
    if (operationPrefix) {
        graphQLFieldName = `${operationPrefix}${usePlural ? pluralNamePascalCase : namePascalCase}`;
    }
    else if (indexMeta) {
        const { queryField, pk, sk = [] } = indexMeta;
        graphQLFieldName = queryField;
        const skQueryArgs = sk.reduce((acc, fieldName) => {
            const fieldType = Object.prototype.hasOwnProperty.call(fields[fieldName].type, 'enum')
                ? 'String' // AppSync schema sets `ModelStringKeyConditionInput` as the type of the enum field that's used as SK
                : fields[fieldName].type;
            acc[fieldName] = `Model${fieldType}KeyConditionInput`;
            return acc;
        }, {});
        indexQueryArgs = {
            [pk]: `${Object.prototype.hasOwnProperty.call(fields[pk].type, 'enum')
                ? fields[pk].type.enum // AppSync schema sets enum type as the type of the enum fields that's used as PK
                : fields[pk].type}!`,
            ...skQueryArgs,
        };
    }
    else {
        throw new Error('Error generating GraphQL Document - invalid operation name');
    }
    let graphQLOperationType;
    let graphQLSelectionSet;
    let graphQLArguments;
    const selectionSetFields = generateSelectionSet(modelIntrospection, modelName, selectionSet);
    // default PK args for get and list operations
    // modified below for CPK
    const getPkArgs = {
        [primaryKeyFieldName]: `${fields[primaryKeyFieldName].type}!`,
    };
    const listPkArgs = {};
    const generateSkArgs = (op) => {
        return sortKeyFieldNames.reduce((acc, fieldName) => {
            const fieldType = fields[fieldName].type;
            if (op === 'get') {
                acc[fieldName] = `${fieldType}!`;
            }
            else if (op === 'list') {
                acc[fieldName] = `Model${fieldType}KeyConditionInput`;
            }
            return acc;
        }, {});
    };
    if (isCustomPrimaryKey) {
        Object.assign(getPkArgs, generateSkArgs('get'));
        Object.assign(listPkArgs, {
            // PK is only included in list query field args in the generated GQL
            // when explicitly specifying PK with .identifier(['fieldName']) or @primaryKey in the schema definition
            [primaryKeyFieldName]: `${fields[primaryKeyFieldName].type}`, // PK is always a nullable arg for list (no `!` after the type)
            sortDirection: 'ModelSortDirection',
        }, generateSkArgs('list'));
    }
    switch (modelOperation) {
        case 'CREATE':
        case 'UPDATE':
        case 'DELETE':
            graphQLArguments ??
                (graphQLArguments = {
                    input: `${operationPrefix.charAt(0).toLocaleUpperCase() +
                        operationPrefix.slice(1)}${namePascalCase}Input!`,
                });
            graphQLOperationType ?? (graphQLOperationType = 'mutation');
        // TODO(Eslint): this this case clause correct without the break statement?
        // eslint-disable-next-line no-fallthrough
        case 'READ':
            graphQLArguments ?? (graphQLArguments = getPkArgs);
            graphQLSelectionSet ?? (graphQLSelectionSet = selectionSetFields);
        // TODO(Eslint): this this case clause correct without the break statement?
        // eslint-disable-next-line no-fallthrough
        case 'LIST':
            graphQLArguments ??
                (graphQLArguments = {
                    ...listPkArgs,
                    // eslint doesn't like the ts-ignore, because it thinks it's unnecessary.
                    // But TS doesn't like the `filter: ...` because it think it will always be
                    // overwritten. (it won't be.) so, we need to ignore the TS error and then
                    // ignore the eslint error on the ts-ignore.
                    // eslint-disable-next-line
                    // @ts-ignore
                    filter: `Model${namePascalCase}FilterInput`,
                    limit: 'Int',
                    nextToken: 'String',
                });
            graphQLOperationType ?? (graphQLOperationType = 'query');
            graphQLSelectionSet ??
                (graphQLSelectionSet = `items { ${selectionSetFields} } nextToken __typename`);
        // TODO(Eslint): this this case clause correct without the break statement?
        // eslint-disable-next-line no-fallthrough
        case 'INDEX_QUERY':
            graphQLArguments ??
                (graphQLArguments = {
                    ...indexQueryArgs,
                    filter: `Model${namePascalCase}FilterInput`,
                    sortDirection: 'ModelSortDirection',
                    limit: 'Int',
                    nextToken: 'String',
                });
            graphQLOperationType ?? (graphQLOperationType = 'query');
            graphQLSelectionSet ??
                (graphQLSelectionSet = `items { ${selectionSetFields} } nextToken __typename`);
        // TODO(Eslint): this this case clause correct without the break statement?
        // eslint-disable-next-line no-fallthrough
        case 'ONCREATE':
        case 'ONUPDATE':
        case 'ONDELETE':
            graphQLArguments ??
                (graphQLArguments = {
                    filter: `ModelSubscription${namePascalCase}FilterInput`,
                });
            graphQLOperationType ?? (graphQLOperationType = 'subscription');
            graphQLSelectionSet ?? (graphQLSelectionSet = selectionSetFields);
            break;
        case 'OBSERVE_QUERY':
        default:
            throw new Error('Internal error: Attempted to generate graphql document for observeQuery. Please report this error.');
    }
    const graphQLDocument = `${graphQLOperationType}${graphQLArguments
        ? `(${Object.entries(graphQLArguments).map(([fieldName, type]) => `$${fieldName}: ${type}`)})`
        : ''} { ${graphQLFieldName}${graphQLArguments
        ? `(${Object.keys(graphQLArguments).map((fieldName) => `${fieldName}: $${fieldName}`)})`
        : ''} { ${graphQLSelectionSet} } }`;
    return graphQLDocument;
}
exports.generateGraphQLDocument = generateGraphQLDocument;
function buildGraphQLVariables(modelDefinition, operation, arg, modelIntrospection, indexMeta) {
    const { fields, primaryKeyInfo: { isCustomPrimaryKey, primaryKeyFieldName, sortKeyFieldNames, }, } = modelDefinition;
    let variables = {};
    // TODO: process input
    switch (operation) {
        case 'CREATE':
            variables = {
                input: arg
                    ? normalizeMutationInput(arg, modelDefinition, modelIntrospection)
                    : {},
            };
            break;
        case 'UPDATE':
            // readonly fields are not  updated
            variables = {
                input: arg
                    ? Object.fromEntries(Object.entries(normalizeMutationInput(arg, modelDefinition, modelIntrospection)).filter(([fieldName]) => {
                        const { isReadOnly } = fields[fieldName];
                        return !isReadOnly;
                    }))
                    : {},
            };
            break;
        case 'READ':
        case 'DELETE':
            // only identifiers are sent
            if (arg) {
                variables = isCustomPrimaryKey
                    ? [primaryKeyFieldName, ...sortKeyFieldNames].reduce((acc, fieldName) => {
                        acc[fieldName] = arg[fieldName];
                        return acc;
                    }, {})
                    : { [primaryKeyFieldName]: arg[primaryKeyFieldName] };
            }
            if (operation === 'DELETE') {
                variables = { input: variables };
            }
            break;
        case 'LIST':
            if (arg?.filter) {
                variables.filter = arg.filter;
            }
            if (arg?.sortDirection) {
                variables.sortDirection = arg.sortDirection;
                variables[primaryKeyFieldName] = arg[primaryKeyFieldName];
            }
            if (arg?.nextToken) {
                variables.nextToken = arg.nextToken;
            }
            if (arg?.limit) {
                variables.limit = arg.limit;
            }
            break;
        case 'INDEX_QUERY': {
            const { pk, sk = [] } = indexMeta;
            variables[pk] = arg[pk];
            for (const skField of sk) {
                variables[skField] = arg[skField];
            }
            if (arg?.filter) {
                variables.filter = arg.filter;
            }
            if (arg?.sortDirection) {
                variables.sortDirection = arg.sortDirection;
            }
            if (arg?.nextToken) {
                variables.nextToken = arg.nextToken;
            }
            if (arg?.limit) {
                variables.limit = arg.limit;
            }
            break;
        }
        case 'ONCREATE':
        case 'ONUPDATE':
        case 'ONDELETE':
            if (arg?.filter) {
                variables = { filter: arg.filter };
            }
            break;
        case 'OBSERVE_QUERY':
            throw new Error('Internal error: Attempted to build variables for observeQuery. Please report this error.');
        default: {
            const exhaustiveCheck = operation;
            throw new Error(`Unhandled operation case: ${exhaustiveCheck}`);
        }
    }
    return variables;
}
exports.buildGraphQLVariables = buildGraphQLVariables;
/**
 * Iterates over mutation input values and resolves any model inputs to their corresponding join fields/values
 *
 * @example
 * ### Usage
 * ```ts
 * const result = normalizeMutationInput({ post: post }, model, modelDefinition);
 * ```
 * ### Result
 * ```ts
 * { postId: "abc123" }
 * ```
 *
 */
function normalizeMutationInput(mutationInput, model, modelIntrospection) {
    const { fields } = model;
    const normalized = {};
    Object.entries(mutationInput).forEach(([inputFieldName, inputValue]) => {
        const fieldType = fields[inputFieldName]?.type;
        const relatedModelName = fieldType?.model;
        if (relatedModelName) {
            const association = fields[inputFieldName]?.association;
            const relatedModelDef = modelIntrospection.models[relatedModelName];
            const relatedModelPkInfo = relatedModelDef.primaryKeyInfo;
            if (association?.connectionType === connectionType.HAS_ONE) {
                const associationHasOne = association;
                associationHasOne.targetNames.forEach((targetName, idx) => {
                    const associatedFieldName = associationHasOne.associatedWith[idx];
                    normalized[targetName] = inputValue[associatedFieldName];
                });
            }
            if (association?.connectionType === connectionType.BELONGS_TO) {
                const associationBelongsTo = association;
                associationBelongsTo.targetNames.forEach((targetName, idx) => {
                    if (idx === 0) {
                        const associatedFieldName = relatedModelPkInfo.primaryKeyFieldName;
                        normalized[targetName] = inputValue[associatedFieldName];
                    }
                    else {
                        const associatedFieldName = relatedModelPkInfo.sortKeyFieldNames[idx - 1];
                        normalized[targetName] = inputValue[associatedFieldName];
                    }
                });
            }
        }
        else {
            normalized[inputFieldName] = inputValue;
        }
    });
    return normalized;
}
exports.normalizeMutationInput = normalizeMutationInput;
/**
 * Produces a parameter object that can contains auth mode/token overrides
 * only if present in either `options` (first) or configured on the `client`
 * as a fallback.
 *
 * @param client Configured client from `generateClient`
 * @param options Args/Options object from call site.
 * @returns
 */
function authModeParams(client, getInternals, options = {}) {
    const internals = getInternals(client);
    return {
        authMode: options.authMode || internals.authMode,
        authToken: options.authToken || internals.authToken,
    };
}
exports.authModeParams = authModeParams;
/**
 * Retrieves custom headers from either the client or request options.
 * @param client V6Client | V6ClientSSRRequest | V6ClientSSRCookies - for extracting client headers
 * @param requestHeaders {@link CustomHeaders} - request headers
 * @returns custom headers as {@link CustomHeaders}
 */
function getCustomHeaders(client, getInternals, requestHeaders) {
    let headers = getInternals(client).headers || {};
    // Individual request headers will take precedence over client headers.
    // We intentionally do *not* merge client and request headers.
    if (requestHeaders) {
        headers = requestHeaders;
    }
    return headers;
}
exports.getCustomHeaders = getCustomHeaders;
//# sourceMappingURL=APIClient.js.map
